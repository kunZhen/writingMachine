Tokens encontrados:
[('Proc', 'PROC', 2, 1), ('Main', 'ID', 2, 6), ('(', 'LPAREN', 2, 10), (')', 'RPAREN', 2, 11), ('[', 'LBRACKET', 3, 1), ('Pos', 'POS', 4, 1), ('(', 'LPAREN', 4, 5), (2, 'NUMBER', 4, 6), (',', 'COMMA', 4, 7), (2, 'NUMBER', 4, 8), (')', 'RPAREN', 4, 9), (';', 'SEMI', 4, 10), ('Def', 'DEF', 5, 1), ('(', 'LPAREN', 5, 4), ('var', 'ID', 5, 5), (',', 'COMMA', 5, 8), (2, 'NUMBER', 5, 10), (')', 'RPAREN', 5, 11), (';', 'SEMI', 5, 12), ('Down', 'DOWN', 6, 1), (';', 'SEMI', 6, 5), ('ContinueDown', 'CONTINUEDOWN', 7, 1), ('var', 'ID', 7, 14), ('*', 'MULT_OP', 7, 17), (2, 'NUMBER', 7, 18), (';', 'SEMI', 7, 19), ('PosX', 'POSX', 8, 1), (5, 'NUMBER', 8, 6), (';', 'SEMI', 8, 7), ('ContinueRight', 'CONTINUERIGHT', 9, 1), (10, 'NUMBER', 9, 15), (';', 'SEMI', 9, 17), ('ContinueUp', 'CONTINUEUP', 10, 1), (4, 'NUMBER', 10, 12), (';', 'SEMI', 10, 13), ('Up', 'UP', 11, 1), (';', 'SEMI', 11, 3), ('ContinueLeft', 'CONTINUELEFT', 12, 1), (3, 'NUMBER', 12, 14), (';', 'SEMI', 12, 15), ('Down', 'DOWN', 13, 1), (';', 'SEMI', 13, 5), ('PosY', 'POSY', 14, 1), (5, 'NUMBER', 14, 6), (';', 'SEMI', 14, 7), ('ContinueDown', 'CONTINUEDOWN', 15, 1), (2, 'NUMBER', 15, 14), (';', 'SEMI', 15, 15), (']', 'RBRACKET', 16, 1), (';', 'SEMI', 16, 2), ('end', 'END', 17, 1), (';', 'SEMI', 17, 4)]

AST: <ast_custom.program.Program object at 0x0000021333FEC9D0>
Registrando procedimiento: Main
Procedimiento Main registrado con 0 parámetros: []
Ejecutando el procedimiento 'Main'...

Ejecutando llamada al procedimiento: Main con 0 argumentos
Ejecutando cuerpo del procedimiento Main
Posicion actualizada a X: 2, Y: 2
Definido var = 2 (Tipo: NUMBER)
Lapicero colocado en la superficie (Down)
Operando izquierdo: 2, Operando derecho: 2, Operador: *
4
Movido 4 unidades hacia abajo. Nueva posicion en Y: 6
Posicion actualizada a X: 5, Y: 6
Movido 10 unidades hacia la derecha. Nueva posición en X: 15
Movido 4 unidades hacia arriba. Nueva posicion en Y: 2
Lapicero levantado de la superficie (Up)
Movido 3 unidades hacia la izquierda. Nueva posición en X: %"updated_x" = load i32, i32* @"x_position"
Lapicero colocado en la superficie (Down)
Posicion actualizada a X: %"updated_x" = load i32, i32* @"x_position", Y: 5
Movido 2 unidades hacia abajo. Nueva posicion en Y: 7
Finalizada la ejecución del procedimiento Main


AST:
Program
  statements: [
  ProcedureStatement
    procedure_name: Main
    arguments: [
    ]
    body: [
    Program
      statements: [
      PosStatement
        x_val:
        Expression
          value:
          NumberExpression
            value: 2
        y_val:
        Expression
          value:
          NumberExpression
            value: 2
      DefStatement
        var_name: var
        value:
        Expression
          value:
          NumberExpression
            value: 2
      DownStatement
      ContinueDownStatement
        move_units:
        Expression
          value:
          BinaryOperation
            left:
            IdExpression
              var_name: var
            operator: *
            right:
            NumberExpression
              value: 2
      PosXStatement
        x_val:
        Expression
          value:
          NumberExpression
            value: 5
      ContinueRightStatement
        move_units:
        Expression
          value:
          NumberExpression
            value: 10
      ContinueUpStatement
        move_units:
        Expression
          value:
          NumberExpression
            value: 4
      UpStatement
      ContinueLeftStatement
        move_units:
        Expression
          value:
          NumberExpression
            value: 3
      DownStatement
      PosYStatement
        y_val:
        Expression
          value:
          NumberExpression
            value: 5
      ContinueDownStatement
        move_units:
        Expression
          value:
          NumberExpression
            value: 2
      ]
    ]
  ]
Symbol Table:
Name       Type       Procedure       Value
--------------------------------------------------
var        NUMBER     Main            2
El IR es válido antes de optimización.
Optimización completada. IR optimizado:
; ModuleID = '<string>'
source_filename = "<string>"
target triple = "unknown-unknown-unknown"

@x_position = common global i32 0
@y_position = common global i32 0
@pen_down = common global i1 false

define void @Main() {
entry:
  store i32 2, i32* @x_position, align 4
  fence seq_cst
  store i32 2, i32* @y_position, align 4
  fence seq_cst
  store i1 true, i1* @pen_down, align 1
  fence seq_cst
  %current_y = load i32, i32* @y_position, align 4
  %new_y = add i32 %current_y, 4
  store i32 %new_y, i32* @y_position, align 4
  fence seq_cst
  store i32 5, i32* @x_position, align 4
  fence seq_cst
  %current_x = load i32, i32* @x_position, align 4
  %new_x = add i32 %current_x, 10
  store i32 %new_x, i32* @x_position, align 4
  fence seq_cst
  %current_y.1 = load i32, i32* @y_position, align 4
  %new_y.1 = add i32 %current_y.1, -4
  store i32 %new_y.1, i32* @y_position, align 4
  fence seq_cst
  store i1 false, i1* @pen_down, align 1
  fence seq_cst
  %current_x.1 = load i32, i32* @x_position, align 4
  %new_x.1 = add i32 %current_x.1, -3
  store i32 %new_x.1, i32* @x_position, align 4
  fence seq_cst
  store i1 true, i1* @pen_down, align 1
  fence seq_cst
  store i32 5, i32* @y_position, align 4
  fence seq_cst
  %current_y.2 = load i32, i32* @y_position, align 4
  %new_y.2 = add i32 %current_y.2, 2
  store i32 %new_y.2, i32* @y_position, align 4
  fence seq_cst
  ret void
}

El IR es válido después de optimización.
; ModuleID = '<string>'
source_filename = "<string>"
target triple = "unknown-unknown-unknown"

@x_position = common global i32 0
@y_position = common global i32 0
@pen_down = common global i1 false

define void @Main() {
entry:
  store i32 2, i32* @x_position, align 4
  fence seq_cst
  store i32 2, i32* @y_position, align 4
  fence seq_cst
  store i1 true, i1* @pen_down, align 1
  fence seq_cst
  %current_y = load i32, i32* @y_position, align 4
  %new_y = add i32 %current_y, 4
  store i32 %new_y, i32* @y_position, align 4
  fence seq_cst
  store i32 5, i32* @x_position, align 4
  fence seq_cst
  %current_x = load i32, i32* @x_position, align 4
  %new_x = add i32 %current_x, 10
  store i32 %new_x, i32* @x_position, align 4
  fence seq_cst
  %current_y.1 = load i32, i32* @y_position, align 4
  %new_y.1 = add i32 %current_y.1, -4
  store i32 %new_y.1, i32* @y_position, align 4
  fence seq_cst
  store i1 false, i1* @pen_down, align 1
  fence seq_cst
  %current_x.1 = load i32, i32* @x_position, align 4
  %new_x.1 = add i32 %current_x.1, -3
  store i32 %new_x.1, i32* @x_position, align 4
  fence seq_cst
  store i1 true, i1* @pen_down, align 1
  fence seq_cst
  store i32 5, i32* @y_position, align 4
  fence seq_cst
  %current_y.2 = load i32, i32* @y_position, align 4
  %new_y.2 = add i32 %current_y.2, 2
  store i32 %new_y.2, i32* @y_position, align 4
  fence seq_cst
  ret void
}

Código ensamblador generado exitosamente.
Archivo ensamblador guardado como output.s
Archivo ensamblador limpio guardado como output.s
Archivo ensamblador limpio guardado como output.s
Archivo objeto generado como output.o
Archivo objeto generado exitosamente: output.o
