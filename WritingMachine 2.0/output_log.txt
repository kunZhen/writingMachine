Tokens encontrados:
[('Proc', 'PROC', 3, 1), ('linea2', 'ID', 3, 6), ('(', 'LPAREN', 3, 13), ('var1', 'ID', 3, 14), (')', 'RPAREN', 3, 18), ('[', 'LBRACKET', 4, 1), ('Def', 'DEF', 5, 1), ('(', 'LPAREN', 5, 4), ('var1', 'ID', 5, 5), (',', 'COMMA', 5, 9), (1, 'NUMBER', 5, 10), (')', 'RPAREN', 5, 11), (';', 'SEMI', 5, 12), ('While', 'WHILE', 6, 1), ('[', 'LBRACKET', 6, 7), ('var1', 'ID', 6, 8), ('<', 'LT', 6, 12), (4, 'NUMBER', 6, 13), (']', 'RBRACKET', 6, 14), ('[', 'LBRACKET', 7, 1), ('Add', 'ADD', 7, 2), ('(', 'LPAREN', 7, 5), ('var1', 'ID', 7, 6), (')', 'RPAREN', 7, 10), (';', 'SEMI', 7, 11), ('ContinueRight', 'CONTINUERIGHT', 8, 1), (3, 'NUMBER', 8, 15), (';', 'SEMI', 8, 16), (']', 'RBRACKET', 8, 17), ('Whend', 'WHEND', 9, 1), (';', 'SEMI', 9, 6), (']', 'RBRACKET', 10, 1), (';', 'SEMI', 10, 2), ('end', 'END', 11, 1), (';', 'SEMI', 11, 4), ('Proc', 'PROC', 13, 1), ('linea1', 'ID', 13, 6), ('(', 'LPAREN', 13, 12), (')', 'RPAREN', 13, 13), ('[', 'LBRACKET', 14, 1), ('Pos', 'POS', 15, 1), ('(', 'LPAREN', 15, 5), (2, 'NUMBER', 15, 6), (',', 'COMMA', 15, 7), (2, 'NUMBER', 15, 8), (')', 'RPAREN', 15, 9), (';', 'SEMI', 15, 10), ('Def', 'DEF', 16, 1), ('(', 'LPAREN', 16, 4), ('var', 'ID', 16, 5), (',', 'COMMA', 16, 8), (2, 'NUMBER', 16, 10), (')', 'RPAREN', 16, 11), (';', 'SEMI', 16, 12), ('Down', 'DOWN', 17, 1), (';', 'SEMI', 17, 5), ('ContinueDown', 'CONTINUEDOWN', 18, 1), ('var', 'ID', 18, 14), ('*', 'MULT_OP', 18, 17), (2, 'NUMBER', 18, 18), (';', 'SEMI', 18, 19), ('PosX', 'POSX', 19, 1), (5, 'NUMBER', 19, 6), (';', 'SEMI', 19, 7), ('ContinueRight', 'CONTINUERIGHT', 20, 1), (10, 'NUMBER', 20, 15), (';', 'SEMI', 20, 17), ('ContinueUp', 'CONTINUEUP', 21, 1), (4, 'NUMBER', 21, 12), (';', 'SEMI', 21, 13), ('Up', 'UP', 22, 1), (';', 'SEMI', 22, 3), ('Def', 'DEF', 23, 1), ('(', 'LPAREN', 23, 4), ('var2', 'ID', 23, 5), (',', 'COMMA', 23, 9), (4, 'NUMBER', 23, 10), (')', 'RPAREN', 23, 11), (';', 'SEMI', 23, 12), ('Substr', 'SUBSTR', 24, 1), ('(', 'LPAREN', 24, 7), ('var2', 'ID', 24, 8), (',', 'COMMA', 24, 12), (1, 'NUMBER', 24, 13), ('*', 'MULT_OP', 24, 14), (1, 'NUMBER', 24, 15), ('/', 'DIV_OP', 24, 16), (1, 'NUMBER', 24, 17), (')', 'RPAREN', 24, 18), (';', 'SEMI', 24, 19), ('ContinueLeft', 'CONTINUELEFT', 25, 1), ('var2', 'ID', 25, 14), (';', 'SEMI', 25, 18), ('Down', 'DOWN', 26, 1), (';', 'SEMI', 26, 5), ('PosY', 'POSY', 27, 1), (5, 'NUMBER', 27, 6), (';', 'SEMI', 27, 7), ('ContinueDown', 'CONTINUEDOWN', 28, 1), (2, 'NUMBER', 28, 14), (';', 'SEMI', 28, 15), (']', 'RBRACKET', 29, 1), (';', 'SEMI', 29, 2), ('end', 'END', 30, 1), (';', 'SEMI', 30, 4), ('Proc', 'PROC', 32, 1), ('Main', 'ID', 32, 6), ('(', 'LPAREN', 32, 10), (')', 'RPAREN', 32, 11), ('[', 'LBRACKET', 33, 1), ('Down', 'DOWN', 34, 1), (';', 'SEMI', 34, 5), ('Def', 'DEF', 35, 1), ('(', 'LPAREN', 35, 4), ('var', 'ID', 35, 5), (',', 'COMMA', 35, 8), (1, 'NUMBER', 35, 9), (')', 'RPAREN', 35, 10), (';', 'SEMI', 35, 11), ('While', 'WHILE', 36, 1), ('[', 'LBRACKET', 36, 7), ('var', 'ID', 36, 8), ('<', 'LT', 36, 11), (7, 'NUMBER', 36, 12), (']', 'RBRACKET', 36, 13), ('[', 'LBRACKET', 37, 1), ('Add', 'ADD', 37, 2), ('(', 'LPAREN', 37, 5), ('var', 'ID', 37, 6), (')', 'RPAREN', 37, 9), (';', 'SEMI', 37, 10), ('ContinueRight', 'CONTINUERIGHT', 38, 1), (3, 'NUMBER', 38, 15), (';', 'SEMI', 38, 16), ('ContinueDown', 'CONTINUEDOWN', 39, 1), (1, 'NUMBER', 39, 14), (';', 'SEMI', 39, 15), (']', 'RBRACKET', 39, 16), ('Whend', 'WHEND', 40, 1), (';', 'SEMI', 40, 6), (']', 'RBRACKET', 41, 1), (';', 'SEMI', 41, 2), ('end', 'END', 42, 1), (';', 'SEMI', 42, 4)]

AST: <ast_custom.program.Program object at 0x000001BF10C015B0>
Registrando procedimiento: linea2
Procedimiento linea2 registrado con 1 parámetros: ['var1']
Registrando procedimiento: linea1
Procedimiento linea1 registrado con 0 parámetros: []
Registrando procedimiento: Main
Procedimiento Main registrado con 0 parámetros: []
Ejecutando el procedimiento 'Main'...

Ejecutando llamada al procedimiento: Main con 0 argumentos
Ejecutando cuerpo del procedimiento Main
Lapicero colocado en la superficie (Down)
Definido var = 1 (Tipo: NUMBER)
Ejecutando While con condición: <ast_custom.expression.Expression object at 0x000001BF10C07610>
Actualizado var_Main = 2
Movido 3 unidades hacia la derecha. Nueva posición en X: 3
Movido 1 unidades hacia abajo. Nueva posicion en Y: 1
While ejecutado correctamente.
Finalizada la ejecución del procedimiento Main


AST:
Program
  statements: [
  ProcedureStatement
    procedure_name: linea2
    arguments: [
    IdExpression
      var_name: var1
    ]
    body: [
    Program
      statements: [
      DefStatement
        var_name: var1
        value:
        Expression
          value:
          NumberExpression
            value: 1
      Expression
        value:
        WhileStatement
          condition:
          Expression
            value:
            BinaryOperation
              left:
              IdExpression
                var_name: var1
              operator: <
              right:
              NumberExpression
                value: 4
          body: [
          Program
            statements: [
            AddStatement
              var_name: var1
              increment_value: None
            ContinueRightStatement
              move_units:
              Expression
                value:
                NumberExpression
                  value: 3
            ]
          ]
      ]
    ]
  ProcedureStatement
    procedure_name: linea1
    arguments: [
    ]
    body: [
    Program
      statements: [
      PosStatement
        x_val:
        Expression
          value:
          NumberExpression
            value: 2
        y_val:
        Expression
          value:
          NumberExpression
            value: 2
      DefStatement
        var_name: var
        value:
        Expression
          value:
          NumberExpression
            value: 2
      DownStatement
      ContinueDownStatement
        move_units:
        Expression
          value:
          BinaryOperation
            left:
            IdExpression
              var_name: var
            operator: *
            right:
            NumberExpression
              value: 2
      PosXStatement
        x_val:
        Expression
          value:
          NumberExpression
            value: 5
      ContinueRightStatement
        move_units:
        Expression
          value:
          NumberExpression
            value: 10
      ContinueUpStatement
        move_units:
        Expression
          value:
          NumberExpression
            value: 4
      UpStatement
      DefStatement
        var_name: var2
        value:
        Expression
          value:
          NumberExpression
            value: 4
      Expression
        value:
        SubstrStatement
          left:
          Expression
            value:
            IdExpression
              var_name: var2
          right:
          Expression
            value:
            BinaryOperation
              left:
              BinaryOperation
                left:
                NumberExpression
                  value: 1
                operator: *
                right:
                NumberExpression
                  value: 1
              operator: /
              right:
              NumberExpression
                value: 1
      ContinueLeftStatement
        move_units:
        Expression
          value:
          IdExpression
            var_name: var2
      DownStatement
      PosYStatement
        y_val:
        Expression
          value:
          NumberExpression
            value: 5
      ContinueDownStatement
        move_units:
        Expression
          value:
          NumberExpression
            value: 2
      ]
    ]
  ProcedureStatement
    procedure_name: Main
    arguments: [
    ]
    body: [
    Program
      statements: [
      DownStatement
      DefStatement
        var_name: var
        value:
        Expression
          value:
          NumberExpression
            value: 1
      Expression
        value:
        WhileStatement
          condition:
          Expression
            value:
            BinaryOperation
              left:
              IdExpression
                var_name: var
              operator: <
              right:
              NumberExpression
                value: 7
          body: [
          Program
            statements: [
            AddStatement
              var_name: var
              increment_value: None
            ContinueRightStatement
              move_units:
              Expression
                value:
                NumberExpression
                  value: 3
            ContinueDownStatement
              move_units:
              Expression
                value:
                NumberExpression
                  value: 1
            ]
          ]
      ]
    ]
  ]
Symbol Table:
Name       Type       Procedure       Value
--------------------------------------------------
var        NUMBER     Main            2
El IR es válido antes de optimización.
Optimización completada. IR optimizado:
; ModuleID = '<string>'
source_filename = "<string>"
target triple = "unknown-unknown-unknown"

@x_position = common global i32 0
@y_position = common global i32 0
@pen_down = common global i1 false

define void @linea2() {
entry:
  ret void
}

define void @linea1() {
entry:
  ret void
}

define void @Main() {
entry:
  fence seq_cst
  store i1 true, i1* @pen_down, align 1
  fence seq_cst
  %var = alloca i32, align 4
  store i32 1, i32* %var, align 4
  br label %while_condition

while_condition:                                  ; preds = %while_body, %entry
  %var.1 = load i32, i32* %var, align 4
  %.7 = icmp slt i32 %var.1, 7
  br i1 %.7, label %while_body, label %while_end

while_body:                                       ; preds = %while_condition
  %.9 = load i32, i32* %var, align 4
  %.10 = add i32 %.9, 1
  store i32 %.10, i32* %var, align 4
  %current_x = load i32, i32* @x_position, align 4
  %new_x = add i32 %current_x, 3
  store i32 %new_x, i32* @x_position, align 4
  fence seq_cst
  %current_y = load i32, i32* @y_position, align 4
  %new_y = add i32 %current_y, 1
  store i32 %new_y, i32* @y_position, align 4
  fence seq_cst
  br label %while_condition

while_end:                                        ; preds = %while_condition
  ret void
}

El IR es válido después de optimización.
; ModuleID = '<string>'
source_filename = "<string>"
target triple = "unknown-unknown-unknown"

@x_position = common global i32 0
@y_position = common global i32 0
@pen_down = common global i1 false

define void @linea2() {
entry:
  ret void
}

define void @linea1() {
entry:
  ret void
}

define void @Main() {
entry:
  fence seq_cst
  store i1 true, i1* @pen_down, align 1
  fence seq_cst
  %var = alloca i32, align 4
  store i32 1, i32* %var, align 4
  br label %while_condition

while_condition:                                  ; preds = %while_body, %entry
  %var.1 = load i32, i32* %var, align 4
  %.7 = icmp slt i32 %var.1, 7
  br i1 %.7, label %while_body, label %while_end

while_body:                                       ; preds = %while_condition
  %.9 = load i32, i32* %var, align 4
  %.10 = add i32 %.9, 1
  store i32 %.10, i32* %var, align 4
  %current_x = load i32, i32* @x_position, align 4
  %new_x = add i32 %current_x, 3
  store i32 %new_x, i32* @x_position, align 4
  fence seq_cst
  %current_y = load i32, i32* @y_position, align 4
  %new_y = add i32 %current_y, 1
  store i32 %new_y, i32* @y_position, align 4
  fence seq_cst
  br label %while_condition

while_end:                                        ; preds = %while_condition
  ret void
}

Código ensamblador generado exitosamente.
Archivo ensamblador guardado como output.s
Archivo ensamblador limpio guardado como output.s
Archivo ensamblador limpio guardado como output.s
Archivo objeto generado como output.o
Archivo objeto generado exitosamente: output.o
